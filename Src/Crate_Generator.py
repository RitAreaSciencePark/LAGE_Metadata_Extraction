import argparse
import os
import datetime
import sys
from rocrate.rocrate import ROCrate
from rocrate.model.contextentity import ContextEntity

# Import your extractor modules to use their validation logic
import Extractor_BeadStudio
import Extractor_Thermal_Report
import Extractor_FMGeneration
import Extractor_IlluminaSampleSheet
import Extractor_FMAutoTilt
import Extractor_Nanopore    


def generate_folder_rocrate(input_folder):
    # --- Specific Descriptions for RO-Crate Metadata ---
    FILE_DESCRIPTIONS = {
    "pod5_file": "Represent raw signal data captured by the Nanopore device, used for quality control and re-basecalling.",
    "fastq_file": "A text-based sequence storage format, containing both the sequence of DNA/RNA and its quality scores.",
    "sample_sheet": "Tabular data file containing sample identifiers and experimental metadata for downstream analysis.",
    "sequencing_summary": "Quantitative summary of the sequencing run, including read lengths and quality scores.",
    "json_report": "Machine-readable report containing instrument metadata and execution parameters.",
    "report_in_markdown": "Human-readable summary of the sequencing run and primary analysis results.",
    "final_summary": "Text-based summary of the final basecalling and run metrics."
    }
    input_folder_name = os.path.basename(os.path.normpath(input_folder))
    VALID_EXTENSIONS = ('.csv', '.txt', '.json', '.md', '.pod5', '.fastq.gz')

    # --- MIME Type Mapping ---
    MIME_MAP = {
        '.csv': 'text/csv',
        '.txt': 'text/plain',
        '.md': 'text/markdown',
        '.json': 'application/json',
        '.pod5': 'application/octet-stream',  
        '.fastq.gz': 'application/gzip'  
    }
    # ---  Pre-scan to identify types for the description ---
    print(f" Pre-scanning folder for file types in: {input_folder}")

    detected_labels = set()
    extension_counts = {} # Dictionary to store counts: {'.pod5': 10, '.csv': 2...}
    for root, dirs, files in os.walk(input_folder):
        for filename in files:
            ext = os.path.splitext(filename)[1].lower()
            # Handle double extension for .fastq.gz
            if filename.lower().endswith('.fastq.gz'):
                ext = '.fastq.gz'
                
            if ext in VALID_EXTENSIONS:
                # 1. Update Counts
                extension_counts[ext] = extension_counts.get(ext, 0) + 1
                
                # 2. Identify Instrument Labels (Your existing logic)
                full_path = os.path.join(root, filename)
                if Extractor_Nanopore.is_nanopore_file(full_path):
                    detected_labels.add("Nanopore")
                elif Extractor_BeadStudio.is_beadstudio_file(full_path):
                    detected_labels.add("BeadStudio")
                elif Extractor_IlluminaSampleSheet.is_illumina_samplesheet(full_path):
                    detected_labels.add("Illumina")

    # --- Build the Dynamic File Summary String ---
    # Example: "15 .csv files, 450 .pod5 files, 2 .json files"
    file_summary_parts = []
    for ext, count in extension_counts.items():
        file_summary_parts.append(f"{count} {ext} files")
    
    file_summary_str = ", ".join(file_summary_parts) if file_summary_parts else "no relevant data files"
    types_str = "/".join(detected_labels) if detected_labels else "Unknown Platform"

    # ---- Initialize the RO-Crate ----
    crate = ROCrate()

    # ---  Add properties to the Root Entity ---
    crate.root_dataset["name"] = f"LAGE Experimental Raw Dataset for the Repository: {input_folder_name}"
    crate.root_dataset["description"] = (f"This dataset contains {file_summary_str} generated by {types_str} instruments. "
    "It also includes the RO-Crate metadata describing the context of data generation, "
    "including the laboratory environment, the research institute, and the instruments used.") 
    crate.root_dataset["license"] = "https://opensource.org/licenses/MIT"
    crate.root_dataset["keywords"] = ["LAGE", "LADE"]
    crate.root_dataset["datePublished"] = datetime.datetime.now().date().isoformat()

    # --- Organizations ---
    area_science_park = crate.add(
        ContextEntity(crate, "#area-science-park", properties={
            "@type": "Organization",
            "name": "Area Science Park",
            "url": "https://www.areasciencepark.it/en/"
        })
    )

    rit = crate.add(
        ContextEntity(crate, "#rit", properties={
            "@type": "Organization",
            "name": "Research and Technology Institute (RIT)",
            "parentOrganization": {"@id": area_science_park.id}
        })
    )

    lade = crate.add(
        ContextEntity(crate, "#lade", properties={
            "@type": "Organization",
            "name": "Laboratory of Data Engineering (LADE)",
            "url": "https://www.areasciencepark.it/infrastrutture-di-ricerca/data-engineering-lade/",
            "parentOrganization": {"@id": rit.id}
        })
    )

    lage = crate.add(
        ContextEntity(crate, "#lage", properties={
            "@type": "Organization",
            "name": "Laboratory of Genomics and Epigenomics (LAGE)",
            "url": "https://www.areasciencepark.it/en/research-infrastructures/life-sciences/lage-genomics-and-epigenomics-laboratory/",
            "parentOrganization": {"@id": rit.id}
        })
    )

    # ---  Define the Processor (SoftwareApplication)  ---
    ro_crate_script = crate.add(ContextEntity(crate, "#Crate_Generator", properties={
        "@type": "SoftwareApplication",
        "name": "LAGE Folder Descriptor Generator",
        "description": "Script to generate RO-Crate descriptors for lab raw data folders ",
        "creator": {"@id": lade.id},
        "license": "https://opensource.org/licenses/MIT",
        "url": "https://github.com/RitAreaSciencePark/LAGE_Metadata_Extraction/blob/main/Src/Crate_Generator.py"

    }))

    # --- Instruments & Activities Definition ---
    # 1. Nanopore
    instrument_nano = crate.add(ContextEntity(crate, "#promethion-device", properties={
    "@type": "Device",
    "name": "Oxford Nanopore Promethion",
    "manufacturer": "Oxford Nanopore Technologies",
    "model": "Promethion 24/48",
    "url": "https://nanoporetech.com/products/promethion"
    }))
        # Define the sequencing activity associated with the Nanopore device
    run_nano = crate.add(ContextEntity(crate, "#nanopore-sequencing-activity", properties={
        "@type": "CreateAction",
        "name": "Nanopore Sequencing Run", 
        "instrument": {"@id": instrument_nano.id}
    }))

    # 2. Illumina iScan
    instrument_iscan = crate.add(ContextEntity(crate, "#iscan-device", properties={
    "@type": "Device",
    "name": "Illumina iScan",
    "manufacturer": "Illumina",
    "model": "iScan 24/48",
    "url": "https://www.illumina.com/systems/array-scanners/iscan.html"
    }))
        # Define the microarray scanning activity associated with the iScan device
    run_iscan = crate.add(ContextEntity(crate, "#iscan-microarray-activity", properties={
        "@type": "CreateAction", 
        "name": "Microarray Scanning", 
        "instrument": {"@id": instrument_iscan.id}
    }))

    # 3. Illumina NovaSeq
    instrument_novaseq = crate.add(ContextEntity(crate, "#novaseq-device", properties={
    "@type": "Device",
    "name": "Illumina NovaSeq",
    "manufacturer": "Illumina",
    "model": "NovaSeq 6000",
    "url": "https://www.illumina.com/systems/sequencing-platforms/novaseq.html"
    }))
        # Define the sequencing activity associated with the NovaSeq device
    run_novaseq = crate.add(ContextEntity(crate, "#illumina-sequencing-activity", properties={
        "@type": "CreateAction", 
        "name": "Illumina Sequencing Run", 
        "instrument": {"@id": instrument_novaseq.id}
    }))
    
    # Convert to a human-readable string (e.g., "1.2 MB")
    def get_readable_file_size(size_in_bytes):
                for unit in ['B', 'KB', 'MB', 'GB']:
                    if size_in_bytes < 1024.0:
                        return f"{size_in_bytes:.2f} {unit}"
                    size_in_bytes /= 1024.0
                return f"{size_in_bytes:.2f} TB"
    
    # --- PASS 3: Final Scan and Crate Assembly ---
    count = 0
    
    for root, dirs, files in os.walk(input_folder):
        for filename in files:
            # Check extension correctly for .fastq.gz
            if not filename.lower().endswith(VALID_EXTENSIONS):
                continue
            
            full_path = os.path.join(root, filename)
            rel_path = os.path.relpath(full_path, input_folder)
            # Get file size in bytes
            file_size_bytes = os.path.getsize(full_path)
            

            readable_size = get_readable_file_size(file_size_bytes)
            
            # Determine extension for MIME mapping
            ext = ".fastq.gz" if filename.lower().endswith(".fastq.gz") else os.path.splitext(filename)[1].lower()
                
            # Default values
            assigned_run = None
            encoding = MIME_MAP.get(ext, 'application/octet-stream')

            # --- VALIDATION LOGIC ---
            # Check for Nanopore
            if Extractor_Nanopore.is_nanopore_file(full_path):
                assigned_run = run_nano
            
            # Check for BeadStudio (iScan)
            elif Extractor_BeadStudio.is_beadstudio_file(full_path):
                assigned_run = run_iscan
            
            # Check for Illumina Sample Sheets (NovaSeq)
            elif Extractor_IlluminaSampleSheet.is_illumina_samplesheet(full_path):
                assigned_run = run_novaseq
            
            #  Identify the specific subtype using your Nanopore Extractor
            nanopore_subtype = Extractor_Nanopore.is_nanopore_file(full_path)

            #  Get the specific description or fallback to a general one
            custom_description = FILE_DESCRIPTIONS.get(nanopore_subtype)

            if not custom_description:
                # Generic fallback based on extension if not a specific Nanopore type
                if ext == '.csv':
                    custom_description = "Tabular data file containing quantitative results and analysis outputs."
                elif ext in ['.txt', '.md']:
                    custom_description = "Text-based file containing metadata and analysis outputs for data sharing."
                else:
                    custom_description = f"Validated {encoding} data file."

            # Build properties dictionary
            file_props = {
                "name": filename,
                "description": custom_description, # Integrated your descriptions here
                "creator": {"@id": lage.id},
                "encodingFormat": encoding,
               # "contentSize": str(file_size_bytes), # Standard Schema.org expects a string or integer in bytes
                "humanReadableSize": readable_size,  # Custom field for user convenience
                "wasGeneratedBy": {"@id": ro_crate_script.id}
            }

            # Link to the specific Activity/Instrument if identified
            if assigned_run:
                file_props["actionProcess"] = {"@id": assigned_run.id}
                print(f" File Identified & Assigned: {rel_path} -> {assigned_run.id}")
            else:
                print(f" File non Identified  & non Assigned: {rel_path}")

            crate.add_file(full_path, dest_path=rel_path, properties=file_props)
            count += 1

    crate.write(input_folder)
    print(f"\n ✅ Success! Processed {count} files.")
    print(f"Generated Crate ('ro-crate-metadata.json') in: {input_folder}.")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Generate recursive RO-Crate with validation.")
    parser.add_argument("folder_path", help="The root folder to scan")
    args = parser.parse_args()
    
    if os.path.isdir(args.folder_path):
        generate_folder_rocrate(args.folder_path)  # pass actual detected types if available
    else:
        print(f"❌ Error: {args.folder_path} is not a valid directory.")


