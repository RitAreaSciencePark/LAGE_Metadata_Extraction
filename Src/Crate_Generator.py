import argparse
import os
import datetime
import sys
from rocrate.rocrate import ROCrate
from rocrate.model.contextentity import ContextEntity
from rocrate.model.entity import Entity 

# Import your extractor modules to use their validation logic
import Extractor_BeadStudio
import Extractor_Thermal_Report
import Extractor_FMGeneration
import Extractor_IlluminaSampleSheet
import Extractor_FMAutoTilt
import Extractor_Nanopore    

 # Convert to a human-readable string (e.g., "1.2 MB")
def get_readable_file_size(size_in_bytes):
                for unit in ['B', 'KB', 'MB', 'GB']:
                    if size_in_bytes < 1024.0:
                        return f"{size_in_bytes:.2f} {unit}"
                    size_in_bytes /= 1024.0
                return f"{size_in_bytes:.2f} TB"
    
def generate_folder_rocrate(input_folder):
    # --- Specific Descriptions for RO-Crate Metadata ---
    FILE_DESCRIPTIONS = {
    "pod5_file": "Represent raw signal data captured by the Nanopore device, used for quality control and re-basecalling.",
    "fastq_file": "A text-based sequence storage format, containing both the sequence of DNA/RNA and its quality scores.",
    "bam_file": "Binary format for storing aligned sequencing reads, containing both sequence and alignment information.",
    "bam_index_file": "Index file for BAM files, enabling rapid access to specific regions within the BAM file for downstream analysis.",
    "sample_sheet": "Tabular data file containing sample identifiers and experimental metadata for downstream analysis.",
    "sequencing_summary": "Quantitative summary of the sequencing run, including read lengths and quality scores.",
    "json_report": "Machine-readable report containing instrument metadata and execution parameters.",
    "report_in_markdown": "Human-readable summary of the sequencing run and primary analysis results.",
    "final_summary": "Text-based summary of the final basecalling and run metrics."
    }

    input_folder_name = os.path.basename(os.path.normpath(input_folder))
    VALID_EXTENSIONS = ('.csv', '.txt', '.json', '.md', '.pod5', '.fastq.gz', '.bam', '.bam.bai')

    # --- MIME Type Mapping ---
    MIME_MAP = {
        '.csv': 'text/csv',
        '.txt': 'text/plain',
        '.md': 'text/markdown',
        '.json': 'application/json',
        # Nanopore POD5 (no official MIME yet)
        ".pod5": "application/vnd.nanopore.pod5",

        # FASTQ (gzipped) → describe BOTH compression + format (no official MIME yet )
        ".fastq.gz": "application/fastq",

        # Alignment formats (community standard values, no official MIME yet)
        ".bam": "application/x-bam",
        ".bam.bai": "application/x-bam-index"
}

    

    # ---  Pre-scan to identify types for the description ---
    print(f" Pre-scanning folder for file types in: {input_folder}")

    detected_labels = set()
    extension_counts = {} # Dictionary to store counts: {'.pod5': 10, '.csv': 2...}
    for root, dirs, files in os.walk(input_folder):
        for filename in files:
            ext = os.path.splitext(filename)[1].lower()
            # Handle double extension for .fastq.gz
            if filename.lower().endswith('.fastq.gz'):
                ext = '.fastq.gz'
            if filename.lower().endswith('.bam.bai'):
                ext = '.bam.bai'
            if ext in VALID_EXTENSIONS:
                # 1. Update Counts
                extension_counts[ext] = extension_counts.get(ext, 0) + 1
                
                # 2. Identify Instrument Labels (Your existing logic)
                full_path = os.path.join(root, filename)
                if Extractor_Nanopore.is_nanopore_file(full_path):
                    detected_labels.add("Nanopore")
                elif Extractor_BeadStudio.is_beadstudio_file(full_path):
                    detected_labels.add("BeadStudio")
                elif Extractor_IlluminaSampleSheet.is_illumina_samplesheet(full_path):
                    detected_labels.add("Illumina")
    total_files = sum(extension_counts.values())
    # --- Build the Dynamic File Summary String ---
    # Example: "15 .csv files, 450 .pod5 files, 2 .json files"
    file_summary_parts = []
    for ext, count in extension_counts.items():
        file_summary_parts.append(f"{count} {ext} files")
    
    file_summary_str = ", ".join(file_summary_parts) if file_summary_parts else "no relevant data files"
    types_str = "/".join(detected_labels) if detected_labels else "Unknown Platform"

    # ---- Initialize the RO-Crate ----
    crate = ROCrate()


    # ---  Add properties to the Root Entity ---
    crate.root_dataset["name"] = f"LAGE Experimental Raw Dataset for the Repository: {input_folder_name}"
    crate.root_dataset["description"] = (f"This dataset contains {total_files} files generated by {types_str} instruments. "
    "It also includes RO-Crate metadata file (ro-crate-metadata.json) that describes the context of data generation, "
    "such as the laboratory environment, the research institute, and the instruments used." )
    crate.root_dataset["license"] = "https://opensource.org/licenses/MIT"
    crate.root_dataset["keywords"] = ["LAGE", "LADE"]
    crate.root_dataset["datePublished"] = datetime.datetime.now().date().isoformat()

    # --- Organizations ---
    area_science_park = crate.add(
        ContextEntity(crate, "#area-science-park", properties={
            "@type": "Organization",
            "name": "Area Science Park",
            "url": "https://www.areasciencepark.it/en/"
        })
    )

    rit = crate.add(
        ContextEntity(crate, "#rit", properties={
            "@type": "Organization",
            "name": "Research and Technology Institute (RIT)",
            "parentOrganization": {"@id": area_science_park.id}
        })
    )

    lade = crate.add(
        ContextEntity(crate, "#lade", properties={
            "@type": "Organization",
            "name": "Laboratory of Data Engineering (LADE)",
            "url": "https://www.areasciencepark.it/infrastrutture-di-ricerca/data-engineering-lade/",
            "parentOrganization": {"@id": rit.id}
        })
    )

    lage = crate.add(
        ContextEntity(crate, "#lage", properties={
            "@type": "Organization",
            "name": "Laboratory of Genomics and Epigenomics (LAGE)",
            "url": "https://www.areasciencepark.it/en/research-infrastructures/life-sciences/lage-genomics-and-epigenomics-laboratory/",
            "parentOrganization": {"@id": rit.id}
        })
    )

    # ---  Define the Processor (SoftwareApplication)  ---
    ro_crate_script = crate.add(ContextEntity(crate, "#Crate_Generator", properties={
        "@type": "SoftwareApplication",
        "name": "LAGE Folder Descriptor Generator",
        "description": "Script to generate RO-Crate descriptors for lab raw data folders ",
        "creator": {"@id": lade.id},
        "license": "https://opensource.org/licenses/MIT",
        "url": "https://github.com/RitAreaSciencePark/LAGE_Metadata_Extraction/blob/main/Src/Crate_Generator.py"

    }))

    # --- Instruments & Activities Definition ---
    # 1. Nanopore
    instrument_nano = crate.add(ContextEntity(crate, "#promethion-device", properties={
    "@type": "Device",
    "name": "Oxford Nanopore Promethion",
    "manufacturer": "Oxford Nanopore Technologies",
    "model": "Promethion 24/48",
    "url": "https://nanoporetech.com/products/promethion"
    }))
        # Define the sequencing activity associated with the Nanopore device
    run_nano = crate.add(ContextEntity(crate, "#nanopore-sequencing-activity", properties={
        "@type": "CreateAction",
        "name": "Nanopore Sequencing Run", 
        "instrument": {"@id": instrument_nano.id}
    }))

    # 2. Illumina iScan
    instrument_iscan = crate.add(ContextEntity(crate, "#iscan-device", properties={
    "@type": "Device",
    "name": "Illumina iScan",
    "manufacturer": "Illumina",
    "model": "iScan 24/48",
    "url": "https://www.illumina.com/systems/array-scanners/iscan.html"
    }))
        # Define the microarray scanning activity associated with the iScan device
    run_iscan = crate.add(ContextEntity(crate, "#iscan-microarray-activity", properties={
        "@type": "CreateAction", 
        "name": "Microarray Scanning", 
        "instrument": {"@id": instrument_iscan.id}
    }))

    # 3. Illumina NovaSeq
    instrument_novaseq = crate.add(ContextEntity(crate, "#novaseq-device", properties={
    "@type": "Device",
    "name": "Illumina NovaSeq",
    "manufacturer": "Illumina",
    "model": "NovaSeq 6000",
    "url": "https://www.illumina.com/systems/sequencing-platforms/novaseq.html"
    }))
        # Define the sequencing activity associated with the NovaSeq device
    run_novaseq = crate.add(ContextEntity(crate, "#illumina-sequencing-activity", properties={
        "@type": "CreateAction", 
        "name": "Illumina Sequencing Run", 
        "instrument": {"@id": instrument_novaseq.id}
    }))
    
         # --- Define  Format Entities ---
    json_format = crate.add(ContextEntity(crate, "#json-format", properties={
        "@type": "File Format",
        "name": "JSON",
        "description": "JavaScript Object Notation (JSON) is a text-based data interchange format.",
        "url": "https://www.json.org/json-en.html"
    }))
    csv_format = crate.add(ContextEntity(crate, "#csv-format", properties={
        "@type": "File Format",
        "name": "CSV",
        "description": "Comma-Separated Values text format.",
        "url": "https://en.wikipedia.org/wiki/Comma-separated_values"
    }))
    txt_format =crate.add(ContextEntity(crate, "#txt-format", properties={
        "@type": "File Format", 
        "name": "Plain Text",
        "description": "Basic text file format containing unformatted text.",
        "url": "https://en.wikipedia.org/wiki/Text_file"
        }))
    md_format = crate.add(ContextEntity(crate, "#markdown-format", properties={
        "@type": "File Format", 
        "name": "Markdown", 
        "description": "Lightweight markup language with plain-text-formatting syntax.",
        "url": "https://www.markdownguide.org/basic-syntax/"
        
        }))
    pod5_format = crate.add(ContextEntity(crate, "#pod5-format", properties={
        "@type": "File Format",
        "name": "POD5", 
        "description": "Nanopore raw signal data format replacing fast5.",
        "url": "https://software-docs.nanoporetech.com/pod5/latest/"
        }))
    fastq_gz_format =crate.add(ContextEntity(crate, "#fastq-gz-format", properties={
        "@type": "File Format", 
        "name": "FASTQ GZipped",
        "description": "Text-based format for storing biological sequences and quality scores.",
        "url":"https://knowledge.illumina.com/software/general/software-general-reference_material-list/000002211.html"
        }))
    bam_format = crate.add(ContextEntity(crate, "#bam-format", properties={
        "@type": "File Format", 
        "name": "BAM (Binary Alignment Map)",
        "description": "Binary representation of the Sequence Alignment/Map (SAM) format.",
        "url":"https://support.illumina.com/help/BS_App_RNASeq_Alignment_OLH_1000000006112/Content/Source/Informatics/BAM-Format.htm"
        }))
    bai_format = crate.add(ContextEntity(crate, "#bai-format", properties={
        "@type": "File Format", 
        "name": "BAI (BAM Index)", 
        "description": "Index file for rapid access to BAM alignment files.",
        "url":"https://en.wikipedia.org/wiki/BAI_(file_format)"
        }))


    # Map MIME types to their corresponding Entity ID
    FORMAT_ENTITY_MAP = {
        'application/json': json_format.id,
        'text/csv': csv_format.id,
        'text/plain': txt_format.id,
        'text/markdown': md_format.id,
        'application/fastq': fastq_gz_format.id, 
        'application/vnd.nanopore.pod5': pod5_format.id,  
        'application/x-bam': bam_format.id,
        'application/x-bam-index': bai_format.id
        
    }
   # ---  Create the Folder (Dataset) Entity ---
    folder_id = f"{input_folder_name}/" # Standard RO-Crate folder ID ends in /
    folder_entity = crate.add(ContextEntity(crate, folder_id, properties={
        "@type": "Dataset",
        "name": input_folder_name,
        "description":f"Main data directory containing sequencing outputs from {types_str} instruments. "
        f"This dataset includes {file_summary_str}.",
        "hasPart": [] # We will fill this with file references (link folder to files ))
    }))

    # Link the Folder to the Root
    crate.root_dataset["hasPart"] = [{"@id": folder_id}]

    total_folder_size = 0
    folder_parts = []



    # ---  Final Scan and Crate Assembly ---
    count = 0
    
    for root, dirs, files in os.walk(input_folder):
        for filename in files:
            # Skip the metadata file itself if it already exists
            if filename == "ro-crate-metadata.json":
                continue
            if not filename.lower().endswith(VALID_EXTENSIONS):
                continue
            
            full_path = os.path.join(root, filename)
            rel_path = os.path.relpath(full_path, input_folder)
            # Get file size in bytes
            file_size_bytes = os.path.getsize(full_path)
            readable_size = get_readable_file_size(file_size_bytes)
            total_folder_size += file_size_bytes

            # Determine extension for MIME mapping
            ext = ".fastq.gz" if filename.lower().endswith(".fastq.gz") else ".bam" if filename.lower().endswith(".bam") else ".bam.bai" if filename.lower().endswith(".bam.bai") else os.path.splitext(filename)[1].lower()
                
            # Default values
            assigned_run = None
            encoding = MIME_MAP.get(ext, 'application/octet-stream')
            format_id = FORMAT_ENTITY_MAP.get(encoding)
            # --- VALIDATION LOGIC ---
            # Check for Nanopore
            if Extractor_Nanopore.is_nanopore_file(full_path):
                assigned_run = run_nano
            
            # Check for BeadStudio (iScan)
            elif Extractor_BeadStudio.is_beadstudio_file(full_path):
                assigned_run = run_iscan
            
            # Check for Illumina Sample Sheets (NovaSeq)
            elif Extractor_IlluminaSampleSheet.is_illumina_samplesheet(full_path):
                assigned_run = run_novaseq
            
            #  Identify the specific subtype using your Nanopore Extractor
            nanopore_subtype = Extractor_Nanopore.is_nanopore_file(full_path)

            #  Get the specific description or fallback to a general one
            custom_description = FILE_DESCRIPTIONS.get(nanopore_subtype)

            if not custom_description:
                # Generic fallback based on extension if not a specific Nanopore type
                if ext == '.csv':
                    custom_description = "Tabular data file containing quantitative results and analysis outputs."
                elif ext in ['.txt', '.md']:
                    custom_description = "Text-based file containing metadata and analysis outputs for data sharing."
                else:
                    custom_description = f"Validated {encoding} data file."

            # Build properties dictionary
            file_props = Entity(crate,identifier=rel_path, properties= {
                "name": filename,
                "@type": "File",
                "description": custom_description, # Integrated specific or generic description
                "creator": {"@id": lage.id},
                "encodingFormat": {"@id": format_id} if format_id else encoding,
                "humanReadableSize": readable_size,  # Custom field for user convenience
                "wasGeneratedBy": {"@id": ro_crate_script.id}
            })  
           
            # Link to the specific Activity/Instrument if identified
            if assigned_run:
                file_props["actionProcess"] = {"@id": assigned_run.id}
                print(f" File Identified & Assigned: {rel_path} -> {assigned_run.id}")
            else:
                print(f" File non Identified  & non Assigned: {rel_path}")
            crate.add(file_props)    

             # Add this file's ID to the folder's list
            folder_parts.append({"@id": rel_path})
            count += 1
    # --- Finalize Folder Properties ---
    folder_entity["hasPart"] = folder_parts
    folder_entity["humanReadableSize"] = get_readable_file_size(total_folder_size)
    crate.write(input_folder)
    print(f"\n ✅ Success! Processed {count} files.")
    print(f"Generated Crate ('ro-crate-metadata.json') in: {input_folder}.")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Generate  RO-Crate with validation.")
    parser.add_argument("folder_path", help="The root folder to scan")
    args = parser.parse_args()
    
    if os.path.isdir(args.folder_path):
        generate_folder_rocrate(args.folder_path)  # pass actual detected types if available
    else:
        print(f"❌ Error: {args.folder_path} is not a valid directory.")


